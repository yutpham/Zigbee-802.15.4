/*******************************************************************************/
//Module: MAC/mac_primitive                                                    */   
//File Name: mac_mlme.c                                                        */
//Description: This file implement the mlme-sap of the MAC                     */
// REUSED and changed from C2430                                               */    
//-----------------------------------------------------------------------------*/
//Revision History:                                                            */
//Date              Programmer      Details                                    */
//02/10/2007        pnthai          Create                                     */
//-----------------------------------------------------------------------------*/
//  Copyright (C) 2006 - All Rights Reserved                                   */
/*******************************************************************************/

/************************************************************************/
/*                  Include files                                       */
/************************************************************************/
#include "types.h"
#include "mac_primitives.h"
#include "mac_mem.h"
#include "mac_packet.h"
#include "mac_tx.h"
#include "phy_primitives.h"
#include "phy_support.h"
#include "schedul.h"
#include "static_timer.h"
#include "mac_state.h"
#include "mac_beacon.h"
#include "mac_tx.h"
#include "mac_mlme.h"
#include "utils.h"
#include "ucos_ii.h"
/************************************************************************/
/*                  Constant declaration                                */
/************************************************************************/

/* A bit-mask containing the valid channels for 2.4 GHz devices 
   (channels 11 to 26)
*/
#define MSC_VALID_CHANNELS                  0x07FFF800


/************************************************************************/
/*                  Type Definition                                     */
/************************************************************************/
/* Information for Association transaction */
typedef struct  
{
    void*           pParam;
    MAC_STATUS      macStatus;
}ASSOCIATION_INFO;

/* Information for Rx Enable Request */
typedef struct  
{
    UINT16          nDuration;    
}RXENABLE_INFO;

/************************************************************************/
/*                  Variable declaration                                */
/************************************************************************/

/* Scan information
*/
MAC_SCAN_INFO*       pScanInfo;

/* Scan result to report to upper layer
*/
MAC_SCAN_RESULT*     pScanResult;
/************************************************************************/
/*                      Static Function                                 */
/************************************************************************/

/******************************************************************************/
//@FunctionName:                                                              */
//@Description: This function will handle association request transition      */
//                                                                            */    
//@Param                                                                      */
//                                                                            */   
/******************************************************************************/
void    mlme_handleAssocTransition(void* par_pParam1,
                                   void* par_Param2);

/************************************************************************/
/*                      Function                                        */
/************************************************************************/


/******************************************************************************/
//@FunctionName:                                                              */
//@Description:   MLME-SET.request structure is generated by the next higher 
//      layer and issued to its MLME to write the indicated MAC PIB attribute
//@Param                                                                      */
//                                                                            */   
/******************************************************************************/
MAC_STATUS mlmeSetRequest(MAC_PIB_ATTR_ID   PIBAttribute,
                          void* pPibAttributeValue)
{
    BOOL    isBeaconEnabledPan  = (mpib.macBeaconOrder < 15);
    WORD    pibAttributeValue;

    // Store the word, not always used but saves memory space
    pibAttributeValue = *((WORD *) pPibAttributeValue);

    switch (PIBAttribute)
    {
        // Category 1 attributes (read-only)
    case MAC_ACK_WAIT_DURATION:
        if ((UINT8) pibAttributeValue == 54)
            break;
        return INVALID_PARAMETER;
    case MAC_BATT_LIFE_EXT_PERIODS:
        if ((UINT8) pibAttributeValue == 6)
            break;
        return INVALID_PARAMETER;
    case MAC_GTS_PERMIT:
    case MAC_PROMISCUOUS_MODE:
        if ((BOOL) pibAttributeValue == FALSE)
            break;
        return INVALID_PARAMETER;

        // Category 2 attributes (direct write)
    case MAC_ASSOCIATION_PERMIT:
        mpib.macAssociationPermit = (BOOL) pibAttributeValue; 
        break;
    case MAC_AUTO_REQUEST:
        mpib.macAutoRequest = (BOOL) pibAttributeValue; 
        break;
    case MAC_BEACON_PAYLOAD_LENGTH:
        if (((UINT8) pibAttributeValue) > aMaxBeaconPayloadLength)
        {
            return INVALID_PARAMETER;
        }
        else
        {
            mpib.macBeaconPayloadLength = (UINT8) pibAttributeValue;
        }
        break;
    case MAC_BSN:
        mpib.macBSN = (UINT8) pibAttributeValue;
        break;
    case MAC_DSN:
        mpib.macDSN = (UINT8) pibAttributeValue;
        break;
    case MAC_MAX_CSMA_BACKOFFS:
        if (((UINT8) pibAttributeValue) > 5)
        {
            return INVALID_PARAMETER;
        }
        else
        {
            mpib.macMaxCSMABackoffs = (UINT8) pibAttributeValue;
        }
        break;
    case MAC_MIN_BE:
        if (((UINT8) pibAttributeValue) > 3)
        {
            return INVALID_PARAMETER;
        }
        else
        {
            mpib.macMinBE = (UINT8) pibAttributeValue;
        }
        break;

        // Category 3 attributes (disable interrupts)        
    case MAC_BEACON_PAYLOAD:
        DISABLE_GLOBAL_INT();
        mpib.macBeaconPayload = (BYTE *) pPibAttributeValue;
        ENABLE_GLOBAL_INT();
        break;
    case MAC_BEACON_TX_TIME:
        DISABLE_GLOBAL_INT();
        mem_cpy(&mpib.macBeaconTxTime,
               (UINT32 *) pPibAttributeValue,
               sizeof(UINT32));
        ENABLE_GLOBAL_INT();
        break;
    case MAC_COORD_EXTENDED_ADDRESS:
        DISABLE_GLOBAL_INT();
        mem_cpy(&mpib.macCoordExtendedAddress,
               (QWORD *) pPibAttributeValue,
				sizeof(QWORD));
        ENABLE_GLOBAL_INT();
        break;
    case MAC_COORD_SHORT_ADDRESS:
        DISABLE_GLOBAL_INT();
        mpib.macCoordShortAddress = pibAttributeValue;
        ENABLE_GLOBAL_INT();
        break;
    case MAC_PAN_ID:
        DISABLE_GLOBAL_INT();
        mpib.macPANId = pibAttributeValue;
        phy_WriteRam((BYTE *) &mpib.macPANId,CC2420RAM_PANID,2,FALSE);
        ENABLE_GLOBAL_INT();
        break;
    case MAC_SHORT_ADDRESS:
        DISABLE_GLOBAL_INT();
        mpib.macShortAddress = pibAttributeValue;
        phy_WriteRam((BYTE *) &mpib.macShortAddress,CC2420RAM_SHORTADDR,2,FALSE);
        ENABLE_GLOBAL_INT();
        break;
    case MAC_TRANSACTION_PERSISTENCE_TIME:
        DISABLE_GLOBAL_INT();
        mpib.macTransactionPersistenceTime = pibAttributeValue;
        ENABLE_GLOBAL_INT();
        break;

        // Category 4 attributes (buffered until beacon transmission / handled carefully)
    case MAC_BATT_LIFE_EXT:
        //TBD
        break;

    case MAC_BEACON_ORDER:
        /*TBD: Handle beacon network change*/ 
        mpib.macBeaconOrder = pibAttributeValue;
        break;
    case MAC_RX_ON_WHEN_IDLE:
        DISABLE_GLOBAL_INT();
        if (isBeaconEnabledPan) {
            macInfo.pibTempBuffer.macRxOnWhenIdle = (BOOL) pibAttributeValue;
            macInfo.pibTempBuffer.updateMask |= MPIB_UPD_RX_ON_WHEN_IDLE_BM;
        } 
        else /* Update directly the value */
            mpib.macRxOnWhenIdle = (BOOL) pibAttributeValue;
        ENABLE_GLOBAL_INT();
        break;
    case MAC_SUPERFRAME_ORDER:
        DISABLE_GLOBAL_INT();
        if (((UINT8) pibAttributeValue) > 15)
        {
            return INVALID_PARAMETER;
        }
#if     ZIGBEE_DEVICE_FFD == TRUE  
        else if ((isBeaconEnabledPan
              && BeaconInfo.bTransmitBeacon) || BeaconInfo.bTrackBeaconReq)
#else
        else if (BeaconInfo.bTrackBeaconReq)
#endif    //! ZIGBEE_DEVICE_FFD == TRUE  
        {
            macInfo.pibTempBuffer.macSuperframeOrder = (UINT8)
                                                       pibAttributeValue;
            macInfo.pibTempBuffer.updateMask |= MPIB_UPD_SUPERFRAME_ORDER_BM;
        }
        else
        {
            mpib.macSuperframeOrder = (UINT8) pibAttributeValue;
        }
        ENABLE_GLOBAL_INT();
        break;

    default:
        return UNSUPPORTED_ATTRIBUTE;
    }
    return SUCCESS;
}


//-----------------------------------------------------------------------------------
// MLME-GET.request structure
// requests information about a given PIB attribute
//-----------------------------------------------------------------------------------
MAC_STATUS mlmeGetRequest(MAC_PIB_ATTR_ID       PIBAttribute,          // The identifier of the PIB sttribute to read
                          void* pPibAttributeValue)  // The value of the PIB sttribute);
{
    /*********** Variable declaration ***********/

    /*********** Function body       ***********/
    switch (PIBAttribute)
    {
    case MAC_ACK_WAIT_DURATION:
        *((BYTE *) pPibAttributeValue) = mpib.macAckWaitDuration; break;
    case MAC_BATT_LIFE_EXT_PERIODS:
        *((BYTE *) pPibAttributeValue) = mpib.macBattLifeExtPeriods; break;
    case MAC_GTS_PERMIT:
        *((BOOL *) pPibAttributeValue) = mpib.macGTSPermit; break;
    case MAC_PROMISCUOUS_MODE:
        *((BOOL *) pPibAttributeValue) = mpib.macPromiscuousMode; break;

    case MAC_ASSOCIATION_PERMIT:
        *((BOOL *) pPibAttributeValue) = mpib.macAssociationPermit; break;
    case MAC_AUTO_REQUEST:
        *((BOOL *) pPibAttributeValue) = mpib.macAutoRequest; break;
    case MAC_BEACON_PAYLOAD_LENGTH:
        *((BYTE *) pPibAttributeValue) = mpib.macBeaconPayloadLength; break;
    case MAC_BSN:
        *((BYTE *) pPibAttributeValue) = mpib.macBSN; break;
    case MAC_DSN:
        *((BYTE *) pPibAttributeValue) = mpib.macDSN; break;
    case MAC_MAX_CSMA_BACKOFFS:
        *((BYTE *) pPibAttributeValue) = mpib.macMaxCSMABackoffs; break;
    case MAC_MIN_BE:
        *((BYTE *) pPibAttributeValue) = mpib.macMinBE; break;

    case MAC_BEACON_PAYLOAD:
        DISABLE_GLOBAL_INT();
        *((BYTE * *) pPibAttributeValue) = mpib.macBeaconPayload; 
        ENABLE_GLOBAL_INT();
        break;
    case MAC_BEACON_TX_TIME:
        DISABLE_GLOBAL_INT();
        mem_cpy(pPibAttributeValue,&mpib.macBeaconTxTime,sizeof(UINT32)); 
        ENABLE_GLOBAL_INT();
        break;
    case MAC_COORD_EXTENDED_ADDRESS:
        DISABLE_GLOBAL_INT();
        mem_cpy(pPibAttributeValue,&mpib.macCoordExtendedAddress,sizeof(QWORD));
        ENABLE_GLOBAL_INT();
        break;
    case MAC_COORD_SHORT_ADDRESS:
        DISABLE_GLOBAL_INT();
        *((WORD *) pPibAttributeValue) = mpib.macCoordShortAddress; 
        ENABLE_GLOBAL_INT();
        break;
    case MAC_PAN_ID:
        DISABLE_GLOBAL_INT();
        *((WORD *) pPibAttributeValue) = mpib.macPANId; 
        ENABLE_GLOBAL_INT();
        break;
    case MAC_SHORT_ADDRESS:
        DISABLE_GLOBAL_INT();
        *((WORD *) pPibAttributeValue) = mpib.macShortAddress;                     
        ENABLE_GLOBAL_INT();
        break;
    case MAC_TRANSACTION_PERSISTENCE_TIME:
        DISABLE_GLOBAL_INT();
        *((WORD *) pPibAttributeValue) = mpib.macTransactionPersistenceTime; 
        ENABLE_GLOBAL_INT();
        break;

        // Category 4 attributes (buffered until beacon transmission / handled carefully)    
    case MAC_BATT_LIFE_EXT:
        //         DISABLE_GLOBAL_INT();
        //         if (macInfo.pibTempBuffer.updateMask & MPIB_UPD_BATT_LIFE_EXT_BM) {
        //             *((BOOL*) pPibAttributeValue) = macInfo.pibTempBuffer.macBattLifeExt; 
        //         } else {
        //             *((BOOL*) pPibAttributeValue) = mpib.macBattLifeExt;                     
        //         }
        //         ENABLE_GLOBAL_INT();
        break;
    case MAC_BEACON_ORDER:
        //         DISABLE_GLOBAL_INT();
        //         if (macInfo.pibTempBuffer.updateMask & MPIB_UPD_BEACON_ORDER_BM) {
        //             *((BOOL*) pPibAttributeValue) = macInfo.pibTempBuffer.macBeaconOrder; 
        //         } else {
        //             *((BOOL*) pPibAttributeValue) = mpib.macBeaconOrder;                     
        //         }
        //         ENABLE_GLOBAL_INT();
        break;
    case MAC_RX_ON_WHEN_IDLE:
        //         DISABLE_GLOBAL_INT();
        //         if (macInfo.pibTempBuffer.updateMask & MPIB_UPD_RX_ON_WHEN_IDLE_BM) {
        //             *((BOOL*) pPibAttributeValue) = macInfo.pibTempBuffer.macRxOnWhenIdle; 
        //         } else {
        //             *((BOOL*) pPibAttributeValue) = mpib.macRxOnWhenIdle;                     
        //         }
        //         ENABLE_GLOBAL_INT();
        break;
    case MAC_SUPERFRAME_ORDER:
        //         DISABLE_GLOBAL_INT();
        //         if (macInfo.pibTempBuffer.updateMask & MPIB_UPD_SUPERFRAME_ORDER_BM) {
        //             *((BOOL*) pPibAttributeValue) = macInfo.pibTempBuffer.macSuperframeOrder; 
        //         } else {
        //             *((BOOL*) pPibAttributeValue) = mpib.macSuperframeOrder;                     
        //         }
        //         ENABLE_GLOBAL_INT();
        break;
    default:
        return UNSUPPORTED_ATTRIBUTE;
    }
    return SUCCESS;
} // End of functions

//---------------------------------------------------------------------------------------------------------------
//---                                           MLME-ASSOCIATE                                                  
//---------------------------------------------------------------------------------------------------------------
// MLME-ASSOCIATE.request structure
// generated by the next higher of an unassociated device and issued to its MLME to request an association 
// with a coordinator
//---------------------------------------------------------------------------------------------------------------
void mlmeAssociateRequest(UINT8   LogicalChannel,        // The logical channel on which to attempt association
                          UINT8   CoordAddrMode,         // The coordinator addressing mode for this primitive and subsequent MPDU
                          UINT16  CoordPANId,            // The identifier of PAN with which to associate
                          ADDRESS*  pCoordAddress,          // The address of the coordinator with which to associate
                          BYTE    CapabilityInformation, // Specifies the operational capabilities of the associating device
                          BOOL    SecurityEnable)        // TRUE if enabled)
{
    /*********** Variable declaration ***********/
    PHY_STATUS  phyStatus;
    MAC_STATUS  macStatus;
    P_MPDU_TX   pMpdu;
    ASSOCIATION_INFO*       pAssoInfo;     /* Information for association */
    /*********** Function body       ***********/
    
    //validate parameters    
    if ((!(LogicalChannel >= 11) && (LogicalChannel <= 26))
     || ((CoordAddrMode != AM_SHORT_16)
      && (CoordAddrMode != AM_EXTENDED_64)))
    {
        mlmeAssociateConfirm(0xFFFF,INVALID_PARAMETER);
        return;
    }    
    /* Checking MAC status */
    if(! mac_requestState(MAC_TRANSAC_ASSOSCIATION, MAC_ASSOC_REQUEST))
    {
        mlmeAssociateConfirm(0xFFFF,UNDEFINED);
        return;
    }    

    //Update PHY current channel
    phyStatus = plmeSET_request(PHY_PIB_CURRENT_CHANNEL,LogicalChannel);

    //update the macPANId
    macStatus = mlmeSetRequest(MAC_PAN_ID,&CoordPANId);
    if (CoordAddrMode == AM_SHORT_16)
    {
        mpib.macCoordShortAddress       = pCoordAddress->Short;
        mpib.macCoordExtendedAddress    = INVALID_EXT_ADDR;                  
    }
    else
    {        
        mpib.macCoordShortAddress       = RESERVED_SHORT_ADDR;                  
        mpib.macCoordExtendedAddress    = pCoordAddress->Extended; 
    }    
    macInfo.DeviceType    = ZIGBEE_ENDPOINT; /*Default device*/

    if (phyStatus != PHY_SUCCESS || macStatus != SUCCESS)
    {
        mlmeAssociateConfirm(0xFFFF,INVALID_PARAMETER);
        return;
    }

    //reserve the packet 
    pMpdu = mem_getFreeTxPkt();
    mem_set(&pMpdu->Mpdu.FrmControl,2);
    if (!pMpdu)
    {
        mlmeAssociateConfirm(0xFFFF,TRANSACTION_OVERFLOW);
        return;
    }

    //Prepare the payload of the ASSO-CMD
    //Command identifier

    pMpdu->Mpdu.PayLoad[0] = CMD_ASSOCIATION_REQUEST;
    pMpdu->Mpdu.PayLoad[1] = CapabilityInformation;

    //set other information
    pMpdu->PktInfo.txMode      = TX_MODE_CSMACA|TX_MODE_FORCE_UNSLOTTED;
    pMpdu->PktInfo.nRetryLeft  = aMaxFrameRetries;

    macStatus = mac_formatMpdu(pMpdu,
                               MAC_FRM_CMD,
                               AM_EXTENDED_64,
                               0xFFFF,
                               (ADDRESS *) &aExtendedAddress,
                               CoordAddrMode,
                               CoordPANId,
                               pCoordAddress,
                               TX_OPT_ACK_REQ,
                               pMpdu->Mpdu.PayLoad,
                               2);

    if (macStatus != SUCCESS)
    {
        mlmeAssociateConfirm(0xFFFF,INVALID_PARAMETER);
        return;
    }
    
    //set other information
    MacTx.bUsedCsmaca = TRUE;
    pMpdu->PktInfo.nRetryLeft = aMaxFrameRetries;

    pAssoInfo = mem_getMem(sizeof(ASSOCIATION_INFO));
    pAssoInfo->macStatus = SUCCESS;
    pAssoInfo->pParam    = pMpdu;  
    schedul_addTask(mlme_handleAssocTransition,TASK_PER_MAC_TRANSACTION,pAssoInfo);
} // End of functions


/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	                                                              */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
P_MPDU_RX               pRxMpdu;
void mlme_notifyAssociation(MAC_STATUS      par_macStatus,
                            void*           par_pParam)
{
	/*********** Variable declaration ***********/
    ASSOCIATION_INFO*       pAssoInfo;     /* Information for association */
    MAC_ASSO_STATE          par_State;
	/*********** Function body		 ***********/
    pRxMpdu     = (P_MPDU_RX)par_pParam;
    pAssoInfo   = (ASSOCIATION_INFO*)schedul_getParam(TASK_PER_MAC_TRANSACTION);

    pAssoInfo->pParam    = par_pParam;
    pAssoInfo->macStatus = par_macStatus;
    if (par_macStatus == SUCCESS)
    {
        if (pRxMpdu->Mpdu.PayLoad[0]==CMD_ASSOCIATION_REQUEST)
        {
            if (macInfo.sState.nTransacState == MAC_ASSOC_REQUEST_SENT)                
                par_State = MAC_ASSOC_DATA_REQUEST; /* Will send data cmd*/
            else
               par_State = MAC_ASSOC_REQUEST_SENT;  /* Sent ass-request cmd*/
        }

        if (pRxMpdu->Mpdu.PayLoad[0]==CMD_DATA_REQUEST)
            par_State = MAC_ASSOC_DATA_REQUEST_SENT;
        if (pRxMpdu->Mpdu.PayLoad[0] == CMD_ASSOCIATION_RESPONSE)
        {
            par_State = MAC_ASSOC_END;
            /* update the PIB information*/
            if (pRxMpdu->Mpdu.FrmControl.SourceAddMode == AM_EXTENDED_64)
                mpib.macCoordExtendedAddress = pRxMpdu->Mpdu.srcAddr.Extended;
            else
                mpib.macCoordShortAddress    = pRxMpdu->Mpdu.srcAddr.Short;
            mlmeSetRequest(MAC_PAN_ID,&pRxMpdu->Mpdu.dstPanId);
            mlmeSetRequest(MAC_SHORT_ADDRESS,(WORD *) &pRxMpdu->Mpdu.PayLoad[1]);
        }
    }
    else 
        par_State = MAC_ASSOC_END;

    mac_requestState(MAC_TRANSAC_ASSOSCIATION, par_State);      /* Set next state */
    schedul_activate(TASK_PER_MAC_TRANSACTION);                 /* active association task */
} // End of functions

/******************************************************************************/
//@FunctionName:                                                              */
//@Description:  This function will clean the association request transition
//               if the association response timeout                          */
//                                                                            */    
//@Param                                                                      */
//                                                                            */   
/******************************************************************************/
void mlme_timeoutAssoDataRes(void* args,void* par_pParam)
{
    mlme_notifyAssociation(NO_DATA,par_pParam);
} // End of functions

void mlme_runAssoDataReq(void* args,void* par_param)
{
    mlme_notifyAssociation(SUCCESS,(void *) par_param);
} // End of functions


/******************************************************************************/
//@FunctionName:                                                              */
//@Description: This function will handle association request transition      */
//                                                                            */    
//@Param                                                                      */
//                                                                            */   
/******************************************************************************/
void mlme_handleAssocTransition(void* par_pParam, 
                                void* args)
{
    /*********** Variable declaration ***********/
    P_MPDU_RX   pRxMpdu;
    UINT8       CommandID;
    MAC_STATUS  macStatus;
    ASSOCIATION_INFO*       pAssoInfo;     /* Information for association */
    /*********** Function body       ***********/
    pAssoInfo = (ASSOCIATION_INFO*)par_pParam;

    switch (macInfo.sState.nTransacState)
    {
    case MAC_ASSOC_REQUEST:
        //transmit the packet
        if(tx_trans((P_MPDU_TX) pAssoInfo->pParam) == FALSE)
        {            
            mlme_notifyAssociation(CHANNEL_ACCESS_FAILURE,NULL);
            mem_releaseTxPkt((P_MPDU_TX) pAssoInfo->pParam);
            mac_requestState(MAC_TRANSAC_ASSOSCIATION, MAC_ASSOC_END);      /* Set next state */
            break;
        }
        schedul_suspend(TASK_PER_MAC_TRANSACTION);
        break;
    case MAC_ASSOC_REQUEST_SENT:
        //set up timer to send data request
        timer_startTimer(runAssoDataReq,
                         pAssoInfo->pParam,
#ifdef ZIGBEE_STUB
						 20
#else
                         (UINT32)aResponseWaitTime / aUnitBackoffPeriod
#endif
                         );
        schedul_suspend(TASK_PER_MAC_TRANSACTION);

        break;
    case MAC_ASSOC_DATA_REQUEST:
        CommandID = CMD_DATA_REQUEST;
        //prepare the data request        
        if (mpib.macCoordShortAddress >= VALID_SHORT_ADDR) // extended address
        {
           macStatus = mac_formatMpdu((P_MPDU_TX) pAssoInfo->pParam,
                           MAC_FRM_CMD,
                           AM_EXTENDED_64,
                           mpib.macPANId,
                           (ADDRESS *) &aExtendedAddress,
                           AM_EXTENDED_64,
                           mpib.macPANId,
                           (ADDRESS *) &mpib.macCoordExtendedAddress,
                           TX_OPT_ACK_REQ,
                           &CommandID,
                           1);
        }
        else
        {
           macStatus = mac_formatMpdu((P_MPDU_TX) pAssoInfo->pParam,
                           MAC_FRM_CMD,
                           AM_EXTENDED_64,
                           mpib.macPANId,
                           (ADDRESS *) &aExtendedAddress,
                           AM_SHORT_16,
                           mpib.macPANId,
                           (ADDRESS *) &mpib.macCoordShortAddress,
                           TX_OPT_ACK_REQ,
                           &CommandID,
                           1);
        }

        if (macStatus != SUCCESS)
        {
            mlmeAssociateConfirm(0xFFFF,INVALID_PARAMETER);
            return;
        }

        /* other information do not need to be set*/
        //transmit the packet
        if(!tx_trans((P_MPDU_TX) pAssoInfo->pParam))
        {
            mem_releaseTxPkt((P_MPDU_TX) pAssoInfo->pParam);
            mac_requestState(MAC_TRANSAC_ASSOSCIATION, MAC_ASSOC_END);      /* Set next state */
        }

        /* wait to be weak up*/
        schedul_suspend(TASK_PER_MAC_TRANSACTION);

        break;
    case MAC_ASSOC_DATA_REQUEST_SENT:
        //release the packet
        mem_releaseTxPkt((P_MPDU_TX) pAssoInfo->pParam);

        //wait for the response from the coord
        timer_startTimer(timeoutAssoDataRes,
                          NULL,
#ifdef ZIGBEE_STUB
						  200
#else
                          (UINT32)aMaxFrameResponseTime / aUnitBackoffPeriod
#endif
                          );
        schedul_suspend(TASK_PER_MAC_TRANSACTION);
        break;
    case MAC_ASSOC_END:

        /* Reset mac state */
        mac_requestState(MAC_TRANSAC_NO,MAC_TRANSAC_NO);

        //received the response
        pRxMpdu = (P_MPDU_RX) pAssoInfo->pParam;

        if (pAssoInfo->macStatus == SUCCESS)
        {
            //cancel the timer
            timer_endTimer(timeoutAssoDataRes);

            //call to upper layer
            mlmeAssociateConfirm(mpib.macShortAddress,SUCCESS);                                       
        }
        else
        {               
            mlmeAssociateConfirm(0xFFFF,pAssoInfo->macStatus);
            if (pAssoInfo->macStatus != NO_DATA ) 
                timer_endTimer(timeoutAssoDataRes); /*cancel the timer*/
        }        

        //release the packet
        if (pAssoInfo->macStatus != NO_DATA 
            && pAssoInfo->macStatus != SUCCESS)
        {
            mem_releaseRxPkt(pRxMpdu);
        }

        mac_setTrxState(PHY_TRX_OFF);
        mem_freeMem(pAssoInfo);
        schedul_removeTask(TASK_PER_MAC_TRANSACTION);        
        break;
    default:
        break;
    }

    return;
} // End of function

#if  ZIGBEE_DEVICE_FFD == 1
/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	                                                              */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void mlmeAssociateResponse(ADDRESS* pDeviceAddress, WORD ShortAddress, 
                           UINT8 status, BOOL securityEnable)
{
	/*********** Variable declaration ***********/
    P_MPDU_TX    pMpduTx;
	/*********** Function body		 ***********/
    pMpduTx = mem_getFreeTxPkt();   /*Allocate the packet*/
    if (!pMpduTx)
    {
        return;
    }

    //set other information    
    pMpduTx->PktInfo.txMode      = TX_MODE_NO_CSMACA;//TX_MODE_CSMACA|TX_MODE_FORCE_UNSLOTTED;
    pMpduTx->PktInfo.nRetryLeft  = aMaxFrameRetries;

    pMpduTx->Mpdu.PayLoad[0] = CMD_ASSOCIATION_RESPONSE;
    mem_cpy(pMpduTx->Mpdu.PayLoad+1,&ShortAddress,sizeof(WORD));
    pMpduTx->Mpdu.PayLoad[3]    = status;  /* status */
    pMpduTx->Mpdu.nLength       = 1+ sizeof(WORD) + 1;   

   
    if (mpib.macShortAddress >= VALID_SHORT_ADDR)
      mac_formatMpdu(pMpduTx,
                   MAC_FRM_CMD,
                   AM_EXTENDED_64,
                   mpib.macPANId,
                   (ADDRESS *) &aExtendedAddress,
                   AM_EXTENDED_64,
                   mpib.macPANId,
                   pDeviceAddress,
                   TX_OPT_INDIRECT|TX_OPT_ACK_REQ,
                   pMpduTx->Mpdu.PayLoad,
                   4);        
    else
    mac_formatMpdu(pMpduTx,
                   MAC_FRM_CMD,
                   AM_SHORT_16,
                   mpib.macPANId,
                   (ADDRESS *) &mpib.macShortAddress,
                   AM_EXTENDED_64,
                   mpib.macPANId,
                   pDeviceAddress,
                   TX_OPT_INDIRECT|TX_OPT_ACK_REQ,
                   pMpduTx->Mpdu.PayLoad,
                   4);        

    indirectTx_addPkt(pMpduTx);
} // End of functions
#endif  //!ZIGBEE_DEVICE_FFD == 1
//-----------------------------------------------------------------------------------------
//---                        MLME-DISASSOCIATE                                                  
//-----------------------------------------------------------------------------------------
// MLME-DISASSOCIATE.request structure
// is used by an associated device to notify the coordinator of its intent to leave the PAN
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
void mlmeDisassociateRequest(QWORD    DeviceAddress,       // The address of the device to which to send the disassociation notification command
                              UINT8    DisassociateReason,   // The reason for disassociation
                              BOOL     SecurityEnable)       // TRUE if enabled for this transfer
{
    /*********** Variable declaration ***********/
    P_MPDU_TX   pMpdu;
    BYTE        Payload[2];
    MAC_STATUS  macStatus;
    /*********** Function body       ***********/    
    //if it is NOT "to coord."
    if((DeviceAddress==mpib.macCoordExtendedAddress) 
        || mac_requestState(MAC_TRANSAC_DISASSOSCIATION,MAC_TRANSAC_DISASSOSCIATION))
    {
        mlmeDisassociateConfirm(UNDEFINED);
        return;
    }
    else
    {
        //else, send the CMD to the coord.
        //prepare the packet
        //reserver a packet
        pMpdu = mem_getFreeTxPkt();
        mem_set(&pMpdu->Mpdu.FrmControl,2);
        if (pMpdu == NULL)
        {
            mlmeDisassociateConfirm(TRANSACTION_OVERFLOW);
            return;
        }    

        Payload[0] = CMD_DISASSOCIATION_NOTIFICATION;
        Payload[1] = DisassociateReason;

        //prepare the data request        
        macStatus = mac_formatMpdu(pMpdu,
                                   MAC_FRM_CMD,
                                   AM_EXTENDED_64,
                                   mpib.macPANId,
                                   (ADDRESS *) &aExtendedAddress,
                                   AM_EXTENDED_64,
                                   mpib.macPANId,
                                   (ADDRESS *) &mpib.macCoordExtendedAddress,
                                   TX_OPT_ACK_REQ,
                                   Payload,
                                   2);

        if (macStatus != SUCCESS)
        {
            mlmeAssociateConfirm(0xFFFF,INVALID_PARAMETER);
            return;
        }

        //set other information
        MacTx.bUsedCsmaca = TRUE;
        pMpdu->PktInfo.nRetryLeft = aMaxFrameRetries;
        //pMpdu->PktInfo.msduHandle = msduHandle; 

        //transmit the packet
        if(!tx_trans(pMpdu))
            mem_releaseTxPkt(pMpdu);
    }

    return;
} // End of functions

/******************************************************************************/
//@FunctionName:                                                              */
//@Description: This function will handle the transition of disassociation req*/
//                                                                            */    
//@Param                                                                      */
//                                                                            */   
/******************************************************************************/
void mlme_handleDisassoTransition(MAC_STATUS par_macStatus,
                                  void* par_Param)
{
    /*********** Variable declaration ***********/
    P_MPDU_TX   pMpdu;
    /*********** Function body       ***********/

    //release the packet 
    pMpdu = (P_MPDU_TX) par_Param;     
    mem_releaseTxPkt(pMpdu);

    //call confirm primitive
    mlmeDisassociateConfirm(par_macStatus);
} // End of functions

/******************************************************************************/
//@FunctionName:                                                              */
//@Description: This function will handle the disassociation req*/
//                                                                            */    
//@Param                                                                      */
//                                                                            */   
/******************************************************************************/
void mlme_handleDisassoReq(MAC_STATUS par_macStatus,
                           void* par_Param)
{
    mlmeDisassociateConfirm(par_macStatus);
} // End of functions


//-------------------------------------------------------------------------------
//---                        MLME-DISASSOCIATE                                                  
//-------------------------------------------------------------------------------
// MLME-RESET.request generated by the next higher layer and issued to its MLME 
// to request a reset of the MAC sublayer to its initial conditions
//-------------------------------------------------------------------------------
/******************************************************************************/
//@FunctionName:                                                              */
//@Description:                                                               */
//                                                                            */    
//@Param                                                                      */
//       SetDefaultPIB: If true the MACsublayer is reset and all MAC 
//                      PIB attributes are set to their default values);      */   
/******************************************************************************/
MAC_STATUS mlmeResetRequest(BOOL       SetDefaultPIB)
{
    /*********** Variable declaration ***********/
    WORD        oldRegVal;
    /*********** Function body       ***********/

    /* Disable the FIFOP interrupt, and also T1_COMPA, 
    which would otherwise turn the FIFOP interrupt back on */ 
    DISABLE_T1_COMPA_INT();
    DISABLE_T1_CAPTURE_INT();

    /* This is the first not time initialization */
    if(macInfo.sState.nTransacType != MAC_INITALIZATION) 
    {
        mac_setTrxState(PHY_TRX_OFF);   /* turn off TRX */
        mem_release();                  /* release the memory in MAC*/
    }

    //reset beacon info
    BeaconInfo.nFinalCapSlot    = 15;
    BeaconInfo.bBatteryLifeExt  = FALSE;
    BeaconInfo.bTrackBeacon     = FALSE;
    BeaconInfo.bTrackBeaconReq  = FALSE;
    BeaconInfo.nBeaconDuration  = 0;
#if     ZIGBEE_DEVICE_FFD == TRUE  
    BeaconInfo.pBeacon          = NULL;
#endif    //! ZIGBEE_DEVICE_FFD == TRUE  
    
    // Reset time stamps and counters
    SlotInfo.bosCounter = 0;
    SlotInfo.captureBosCounter = 0;
    SlotInfo.captureTcnt = 0;
    SlotInfo.captureTime = 0;
    SlotInfo.bosCounterAdjustTime = 0;

    //phy reset
    PhyInfo.bFifopIntOff = FALSE;
    PhyInfo.eState       = PHY_RX_STATE_PHR;
    PhyInfo.nQueueingPkt = 0;

    //set PIB to the default value
    if (SetDefaultPIB)
    {
        PhyInfo.PhyPIB.phyCurrentChannel = 11;
        PhyInfo.PhyPIB.phyTransmitPower = 0x12;
        PhyInfo.PhyPIB.phyCcaMode = 1;

        mpib.macAckWaitDuration = 54;
        mpib.macAssociationPermit = FALSE;
        mpib.macAutoRequest = TRUE;
        mpib.macBattLifeExt = FALSE;
        mpib.macBattLifeExtPeriods = 6;
        mpib.macBeaconPayload = NULL;
        mpib.macBeaconPayloadLength = 0;
        mpib.macBeaconOrder = 15;
        mpib.macBeaconTxTime = 0;
        mpib.macBSN = ramdom_getRandomByte();
        mpib.macCoordShortAddress = INVALID_SHORT_ADDR;
        mpib.macDSN = ramdom_getRandomByte();
        mpib.macGTSPermit = TRUE;
        mpib.macMaxCSMABackoffs = 4;
        mpib.macMinBE = 3;
        mpib.macPANId = 0xFFFF;
        mpib.macPromiscuousMode = FALSE;
        mpib.macRxOnWhenIdle    = TRUE;
        mpib.macShortAddress    = INVALID_SHORT_ADDR;
        mpib.macSuperframeOrder = 15;
        mpib.macTransactionPersistenceTime = 0x0004; //0x01F4
        mpib.macCoordExtendedAddress = 0xFFFF;
    }


    // Configure CC2420 registers
    // Write default register values     
    FASTSPI_SETREG(CC2420_MDMCTRL1, 0x0500);
    FASTSPI_SETREG(CC2420_IOCFG0, 0x0003);
    FASTSPI_SETREG(CC2420_SECCTRL0, CC2420_SECCTRL0_NO_SECURITY);    
    FASTSPI_GETREG(CC2420_RXCTRL1, oldRegVal);    
    oldRegVal |= 0x2000;
    FASTSPI_SETREG(CC2420_RXCTRL1, oldRegVal);    

    // PAN ID, extended and short addresses
    phy_WriteRam(&mpib.macPANId, CC2420RAM_PANID, 2, FALSE);
    phy_WriteRam(&aExtendedAddress, CC2420RAM_IEEEADDR, 8, FALSE);
    phy_WriteRam(&mpib.macShortAddress, CC2420RAM_SHORTADDR, 2, FALSE);
    
    // set the current channel
    plmeSET_request(PHY_PIB_CURRENT_CHANNEL, PhyInfo.PhyPIB.phyCurrentChannel);

    //initialize Tx
    tx_init();

#if ZIGBEE_DEVICE_FFD == TRUE  
    indirectTx_init();
#endif	

    //initialize the task queue, MAC memory
    schedul_resetPerTask();
    mem_initialize();           /* Reset packet management */

    PhyInfo.sCurPacket.pCurRxPacket = mem_getFreeRxPkt();
    
	/* Ready state */
    macInfo.DeviceType  = 0;    /* Device default*/
    macInfo.pibTempBuffer.updateMask = 0;
    macInfo.sState.nTransacType = MAC_TRANSAC_NO;
    
    mlmeResetConfirm(SUCCESS);

    // Turn the interrupts back on
    ENABLE_T1_COMPA_INT();
    ENABLE_T1_CAPTURE_INT();    

    return SUCCESS;
} // End of functions



//---------------------------------------------------------------------------------------------------------------
// MLME-SCAN.request structure
// is used to initiate a channel scan over a given list of channels
//---------------------------------------------------------------------------------------------------------------
/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	This function will handle scan procedure                      */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void  mlme_handleScanTransition(void* par_pParam, void* args);

/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	 This function will handle timeout in scanning procedure      */
//               + Passive scan procedure
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void mlme_scanTimeout()
{
    macInfo.sState.nTransacState = SCAN_FINISHED_CHANNEL;
} // End of functions

/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	 This is the main function of mlme.scanrequest
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void mlmeScanRequest(   UINT8      ScanType,       // Indicates the type of scan
                        DWORD      ScanChannels,   // The 5 MSBs are reserved. The 27 LSBs indicate which channels are to be scanned for each 27 valid channels
                        UINT16     ScanDuration)   // A value used to calculate the length of time to spend scanning each channel for ED, active, and passive scans
{
	/*********** Variable declaration ***********/

	/*********** Function body		 ***********/

    /* Control state for new transition*/
    if(! mac_requestState(MAC_TRANSAC_SCAN, SCAN_INITIALIZATION))
    {
        mlmeScanConfirm(UNDEFINED, NULL);   
        return;
    }
    
    pScanInfo   = mem_getMem(sizeof(MAC_SCAN_INFO));
    if (pScanInfo==NULL)
    {
        mlmeScanConfirm(UNDEFINED, NULL);           
        return;
    }

    if (ScanType != ORPHAN_SCAN)
    {
        pScanResult = mem_getMem(sizeof(MAC_SCAN_RESULT));
        if (pScanResult==NULL)
        {
            mlmeScanConfirm(UNDEFINED, NULL);           
            return;
        }
    }

    /* Store the scan information in to the variable */
    pScanInfo->oldPhyCurrentChannel = PhyInfo.PhyPIB.phyCurrentChannel;
    pScanInfo->scanType = ScanType;
    pScanInfo->scanChannels = ScanChannels;
    pScanInfo->scanDuration = ScanDuration;

    /* Create task to scan*/
    schedul_addTask(mlme_handleScanTransition, TASK_PER_MAC_TRANSACTION, NULL);
    
} // End of functions

/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	This function will handle scan procedure                      */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void  mlme_handleScanTransition(void* par_pParam, void* args)
{
	/*********** Variable declaration ***********/
    WORD            iocfg0;
    DWORD           bitmask = 0x00000001;
    DWORD           panId;
    BOOL            bContinue = FALSE;   
    MAC_STATUS      macStatus;
    UINT8           n;
	/*********** Function body		 ***********/
    switch(macInfo.sState.nTransacState)
    {
    case SCAN_INITIALIZATION:
        
        /* Configure CC2420 for scanning */
        if (pScanInfo->scanType != ORPHAN_SCAN) {
            DISABLE_GLOBAL_INT();
            panId = 0xFFFF;
            FASTSPI_WRITE_RAM_LE(&panId, CC2420RAM_PANID, 2, n);
            
            // Set the BCN_ACCEPT bit 
            FASTSPI_GETREG(CC2420_IOCFG0, iocfg0);
            iocfg0 |= 0x0800;
            FASTSPI_SETREG(CC2420_IOCFG0, iocfg0);
            ENABLE_GLOBAL_INT();
        }     
        /* Prepare the packet for orphan scan */
        if ((pScanInfo->scanType == ORPHAN_SCAN) || (pScanInfo->scanType == ACTIVE_SCAN))
        {
            pScanInfo->pScanCMD = mem_getFreeTxPkt();
            pScanInfo->pScanCMD->Mpdu.PayLoad[0] = 
                (pScanInfo->scanType == ACTIVE_SCAN)? CMD_BEACON_REQUEST:CMD_ORPHAN_NOTIFICATION;
            macStatus = mac_formatMpdu(pScanInfo->pScanCMD,
                                       MAC_FRM_CMD,
                                       AM_EXTENDED_64,
                                       mpib.macPANId,
                                       (ADDRESS *) &aExtendedAddress,
                                       AM_SHORT_16,
                                       mpib.macPANId,
                                       (ADDRESS *) &mpib.macCoordShortAddress,
                                       0,
                                       pScanInfo->pScanCMD->Mpdu.PayLoad,
                                       1);

            //set other information
            pScanInfo->pScanCMD->PktInfo.txMode         = TX_MODE_NO_CSMACA;
            pScanInfo->pScanCMD->PktInfo.nRetryLeft     = aMaxFrameRetries;
        }


        /* Initialize the scan result */
        pScanInfo->scanChannels &= MSC_VALID_CHANNELS;
        pScanInfo->currentChannel = 0;        
        pScanResult->unscannedChannels = pScanInfo->scanChannels;
        pScanResult->resultListSize = 0;        
        pScanResult->scanType = pScanInfo->scanType;
        
        switch(pScanInfo->scanType)
        {
        case ED_SCAN:
        case ACTIVE_SCAN:
        case ORPHAN_SCAN:
            pScanInfo->bRealigned = FALSE;
            break;
        case PASSIVE_SCAN:            
        	break;
        default:
            break;
        }
        
        /* Set next state */
        macInfo.sState.nTransacState = SCAN_INIT_NEW_CHANNEL;                  

    	break;
    case SCAN_INIT_NEW_CHANNEL:   
        
        /* Condition to get next channel */
        switch(pScanInfo->scanType)
        {
        case ED_SCAN:
            break;
        case ORPHAN_SCAN:
            /* No condition check for orphan scan */
            break;
        case ACTIVE_SCAN:
        case PASSIVE_SCAN:
            if (pScanResult->resultListSize >= MAC_MAX_PAN_DESCRIPTOR)
            {
                macInfo.sState.nTransacState = SCAN_FINISHED;                 /* Finish scan */
                break;
            }
        	break;
        default:
            break;
        }
        
        /* Get next channel */    
        pScanInfo->currentChannel++;
        for (int n = 0; n < 27; n++) {
            if (n >= pScanInfo->currentChannel) {
                if (bitmask & pScanInfo->scanChannels) {
                    pScanInfo->currentChannel = n;
                    pScanResult->unscannedChannels &= ~bitmask;
                    bContinue = TRUE;
                    break;
                }
            }
            bitmask = bitmask << 1;
        }
        
        if (bContinue)  /*not finished*/
        {
            /* Set channel */
            plmeSET_request(PHY_PIB_CURRENT_CHANNEL, (UINT32)pScanInfo->currentChannel);
            macInfo.sState.nTransacState = SCAN_SCANNING;
            switch(pScanInfo->scanType)
            {
            case ED_SCAN:
                break;
            case ACTIVE_SCAN:
                /* Send the orphan notification */
                tx_trans(pScanInfo->pScanCMD);
                break;
            case ORPHAN_SCAN:
                /* Send the orphan notification */
                tx_trans(pScanInfo->pScanCMD);
                break;
            case PASSIVE_SCAN:
                /* Set timer to check the timeout */
                timer_startTimer(scanTimeout,NULL, 
                 ((UINT32) aBaseSuperframeDuration / (UINT32) aUnitBackoffPeriod) * (((UINT32) 1 << pScanInfo->scanDuration) + 2));               
                mac_setTrxState(PHY_RX_ON);                  /*Turn on the Rx*/            
            default:
                break;
            }

        }
        else
            macInfo.sState.nTransacState = SCAN_FINISHED; /*Finish scan */
                	break;
    	break;
    case SCAN_SCANNING:        
        break;
    case SCAN_ORPHAN_REALIGNED:            
        break;
    case SCAN_FINISHED_CHANNEL:        
        switch(pScanInfo->scanType)
        {
        case ED_SCAN:  
        case ACTIVE_SCAN:  
        case ORPHAN_SCAN:  
        case PASSIVE_SCAN:
            /*Finish scan on this channel*/        
            macInfo.sState.nTransacState = SCAN_INIT_NEW_CHANNEL; 
        }   
        break;
    case SCAN_FINISHED:

        switch(pScanInfo->scanType)
        {
        case ED_SCAN:  
            break;
        case ORPHAN_SCAN:  
            mem_releaseTxPkt(pScanInfo->pScanCMD); /* release the cmd */
            if (pScanInfo->bRealigned)
                mlmeScanConfirm(SUCCESS,NULL);
            else
                mlmeScanConfirm(NO_BEACON,NULL);
            break;
        case ACTIVE_SCAN:  
        case PASSIVE_SCAN:
            /* Generate a scan confirm */
            if (pScanResult->resultListSize > 0)
                macStatus = SUCCESS;
            else
                macStatus = NO_BEACON;
            mlmeScanConfirm(macStatus, pScanResult);
            break;
        }        

        // Return to normal state
        mac_requestState(MAC_TRANSAC_NO, MAC_TRANSAC_NO);
        
        // Restore CC2420 settings
        if ((pScanInfo->scanType != ORPHAN_SCAN)
            || (pScanInfo->bRealigned == FALSE)) {
            DISABLE_GLOBAL_INT();
            FASTSPI_WRITE_RAM_LE(&mpib.macPANId, CC2420RAM_PANID, 2, n);
            
            // Clear the BCN_ACCEPT bit 
            FASTSPI_GETREG(CC2420_IOCFG0, iocfg0);
            iocfg0 &= ~0x0800;
            FASTSPI_SETREG(CC2420_IOCFG0, iocfg0);
            ENABLE_GLOBAL_INT();

            /* Restore the earlier RX state */
            plmeSET_request(PHY_PIB_CURRENT_CHANNEL, pScanInfo->oldPhyCurrentChannel);
        }             
        
        /* Turn off Rx */
         mac_setTrxState(PHY_TRX_OFF);
        mem_freeMem(pScanInfo);
        pScanInfo = NULL;
        /* Remove the current task */
        schedul_removeTask(TASK_PER_MAC_TRANSACTION);

        break;
    default:
        break;
    }

} // End of functions

/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	 This function will attract the data from the beacon before
//               it is past to upper layer. Information will be store in the
//               SCAN_RESULT structure                                        */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void mlme_handlePktInScan(P_MPDU_RX par_pRxPkt)
{
	/*********** Variable declaration ***********/
    PAN_DESCRIPTOR*         pPanDesc;
    BOOL                    bIgnore;
	/*********** Function body		 ***********/

    switch(pScanInfo->scanType)
    {
    case ED_SCAN:  
        break;
    case ORPHAN_SCAN:  
        macInfo.sState.nTransacState = SCAN_FINISHED;
        pScanInfo->bRealigned = TRUE;
        break; 
    case ACTIVE_SCAN:       /*Update with beacon */
    case PASSIVE_SCAN:
        
        /* Check current available list*/
        if (pScanResult->resultListSize >= MAC_MAX_PAN_DESCRIPTOR)
        {
            /* Cancel the timeout for the current channel */
            timer_endTimer(scanTimeout);

            /*Set end-state */
            macInfo.sState.nTransacState = SCAN_FINISHED_CHANNEL;
            break;      /* Just ignore it*/
        }
        bIgnore = FALSE;
        /* Check if beacon is existing in the list */
        for (int i = 0; i < pScanResult->resultListSize; i++) {
            pPanDesc = &pScanResult->pPANDescriptorList[i];
            if ((par_pRxPkt->Mpdu.FrmControl.SourceAddMode == pPanDesc->CoordAddrMode) &&
                (par_pRxPkt->Mpdu.srcPanId   == pPanDesc->CoordPANId) &&
                (pScanInfo->currentChannel == pPanDesc->LogicalChannel)) {

                if (par_pRxPkt->Mpdu.FrmControl.SourceAddMode == AM_EXTENDED_64) {
                    if (par_pRxPkt->Mpdu.srcAddr.Extended == pPanDesc->CoordAddress.Extended) 
                    {
                        bIgnore = TRUE;
                        break;      /* Just ignore it*/                        
                    }
                } else 
                    if (par_pRxPkt->Mpdu.srcAddr.Short == pPanDesc->CoordAddress.Short) 
                    {
                        bIgnore = TRUE;
                        break;      /* Just ignore it*/
                    }
            }
        }        

        if(!bIgnore)
        {
            /* Finished the current channel */
            pScanResult->resultListSize++;

            pPanDesc = &pScanResult->pPANDescriptorList[pScanResult->resultListSize-1];
            pPanDesc->CoordAddrMode = par_pRxPkt->Mpdu.FrmControl.SourceAddMode;
            pPanDesc->CoordPANId = par_pRxPkt->Mpdu.srcPanId;
            pPanDesc->CoordAddress = par_pRxPkt->Mpdu.srcAddr;
            pPanDesc->LogicalChannel = pScanInfo->currentChannel;
            pPanDesc->SuperframeSpec = *((WORD *)par_pRxPkt->Mpdu.PayLoad);
            pPanDesc->LinkQuality    = par_pRxPkt->Mpdu.Fcs.LinkQuality;
            pPanDesc->GTSPermit = !!(par_pRxPkt->Mpdu.PayLoad[2] & 0x80);        
            pPanDesc->SecurityFailure = par_pRxPkt->Mpdu.FrmControl.SecurityEnable; 
        }
        break;
    }    

} // End of functions

//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
//---                                           MLME-POLL                                                  
//---------------------------------------------------------------------------------------------------------------
// The MLME-POLL.request primitive prompts the device to request data from the coordinator.
//---------------------------------------------------------------------------------------------------------------
MAC_STATUS mlmePollRequest(BYTE coordAddrMode, ADDRESS *coordAddress, WORD coordPANId, BOOL securityEnable)
{
	/*********** Variable declaration ***********/
    P_MPDU_TX           pTxMpdu;
    MAC_STATUS          macStatus;
	/*********** Function body		 ***********/    

    /* Checking MAC status */
    if (mac_requestState(MAC_TRANSAC_POLL, POLL_INIT))
        return  TRANSACTION_OVERFLOW;

    /* validate parameters */   
    if (((coordAddrMode != AM_SHORT_16)
      && (coordAddrMode != AM_EXTENDED_64)))
        return INVALID_PARAMETER;

    /* Prepare the frame request */
    pTxMpdu = mem_getFreeTxPkt();
    mem_set(&pTxMpdu->Mpdu.FrmControl,2);
    if (!pTxMpdu)
        return TRANSACTION_OVERFLOW;

    //Prepare the payload of the POLL.Req
    pTxMpdu->Mpdu.PayLoad[0] = CMD_DATA_REQUEST;

    //Set other information
    pTxMpdu->PktInfo.txMode      = TX_MODE_NO_CSMACA;
    pTxMpdu->PktInfo.nRetryLeft  = aMaxFrameRetries;
        
    macStatus = mac_formatMpdu(pTxMpdu,
                               MAC_FRM_CMD,
                               AM_EXTENDED_64,
                               coordPANId, /*TBD*/
                               (ADDRESS *) &aExtendedAddress,
                               coordAddrMode,
                               coordPANId,
                               (ADDRESS *) coordAddress,
                               TX_OPT_ACK_REQ,
                               pTxMpdu->Mpdu.PayLoad,
                               1);

    if (macStatus != SUCCESS)
        mlmePollConfirm(INVALID_PARAMETER);

    if(tx_trans(pTxMpdu)) /* Transmission */  
        mem_releaseTxPkt(pTxMpdu);

    return SUCCESS;
} // End of functions
/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	                                                              */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void    mlme_autoPollTask(void* arg1,void* arg2)
{
	/*********** Variable declaration ***********/
    MAC_STATUS  Status;
	/*********** Function body		 ***********/
    if (mpib.macCoordShortAddress >= VALID_SHORT_ADDR)
        Status = mlmePollRequest(AM_SHORT_16, mpib.macPANId, (ADDRESS*)&mpib.macCoordShortAddress, FALSE);
    else
        Status = mlmePollRequest(AM_EXTENDED_64, mpib.macPANId, (ADDRESS*)&mpib.macCoordExtendedAddress, FALSE);

    if(Status == SUCCESS)
        schedul_removeTask(TASK_PER_MAC_TRANSACTION);
    /*if not success try later*/
} // End of functions
/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	                                                              */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void    mlme_autoPoll(){
    schedul_addTask(mlme_autoPollTask,TASK_PER_MAC_TRANSACTION,NULL);
}
/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	                                                              */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void    mlme_handlePollTransition(MAC_STATUS    par_macStatus, void* par_pParam)
{
	/*********** Variable declaration ***********/
    P_MPDU_RX       pRxMpdu;
	/*********** Function body		 ***********/
    switch(macInfo.sState.nTransacState)
    {
    case POLL_INIT:
        switch(par_macStatus)
        {
        case INVALID_PARAMETER:
        case CHANNEL_ACCESS_FAILURE:
        case NO_ACK:
            mlmePollConfirm(par_macStatus);
            mac_requestState(MAC_TRANSAC_NO, MAC_TRANSAC_NO);
            break;
        case SUCCESS:
            if (MacTx.bFrmPending == 1)
            {
                /* Set to state to received the response, keep RX on*/
                mac_requestState(MAC_TRANSAC_POLL, POLL_SENT_REQUEST);
                timer_startTimer(timeoutPoll,NULL, (UINT32)aMaxFrameResponseTime / aUnitBackoffPeriod);
            }
            else /* Received ACK but no data */
            {
                mlmePollConfirm(NO_DATA);
                mac_requestState(MAC_TRANSAC_NO, MAC_TRANSAC_NO);                
            }
            break;
        }
        mem_releaseTxPkt((P_MPDU_TX)par_pParam);        /* Release the packet */
    	break;
    case POLL_SENT_REQUEST:                             /* Do nothing */        
    	break;
    case POLL_FINISHED:                                 /* received the data */
        pRxMpdu = (P_MPDU_RX)par_pParam;
        /* Check the received frame */
        if (pRxMpdu == NULL)                            /* Time out */                     
        {
            mlmePollConfirm(NO_DATA);
            mac_requestState(MAC_TRANSAC_NO, MAC_TRANSAC_NO);                
        }
        else                                            /* Received the data */           
        {
            if ((pRxMpdu->Mpdu.FrmControl.FrameType == MAC_FRM_CMD)
                ||(pRxMpdu->Mpdu.nLength == 0) )          /* Received cmd or zero length */
            {
                mlmePollConfirm(NO_DATA);                
            }
            if (pRxMpdu->Mpdu.nLength != 0)             /* Received a frame */
            {
                mlmePollConfirm(SUCCESS);                
            }
            timer_endTimer(timeoutPoll); /* End timer */            
            mac_requestState(MAC_TRANSAC_NO, MAC_TRANSAC_NO); /* End the transaction */                
        }         
        break;
    default:
        break;
    }

} // End of functions

/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	                                                              */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void    mlme_timeoutPoll(void* args1, void* args2)
{
    mac_requestState(MAC_TRANSAC_POLL, POLL_FINISHED);
    mlme_handlePollTransition(NO_DATA, NULL);
} // End of functions


//---------------------------------------------------------------------------------------------------------------
//---                                           MLME-RX-ENABLE                                                  
//---------------------------------------------------------------------------------------------------------------
// The MLME-RX-ENABLE.request primitive is generated by the next higher layer and issued to the MLME
// to enable the receiver for a fixed duration, at a time relative to the start of the current or next superframe on
// a beacon-enabled PAN or immediately on a nonbeacon-enabled PAN. The receiver is enabled exactly once
// per primitive request
//---------------------------------------------------------------------------------------------------------------
/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	                                                              */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void mlme_handleRxEnableTask(void* par_pParam, 
                             void* args)
{
	/*********** Variable declaration ***********/
    RXENABLE_INFO*  pRxEndableInfo;
	/*********** Function body		 ***********/
    if (mpib.macBeaconOrder == 15)
    {
        switch(macInfo.sState.nTransacState)
        {
        case RX_ENABLE:
            /* Enable RX only when TX finished the current transmission */
            if(MacTx.eState == MAC_TX_IDLE)
            {   pRxEndableInfo = (RXENABLE_INFO*)par_pParam;
                timer_startTimer(handleRxEnableTask, (UINT32)par_pParam,pRxEndableInfo->nDuration); /*Timer*/
                macInfo.sState.nTransacState = RX_NORMAL;
                schedul_suspend(TASK_PER_MAC_TRANSACTION); /*Keep task in queue */
                mac_setTrxState(PHY_RX_ON);                
            }
            /* Not IDLE, try next */
        	break;
        case RX_NORMAL:            
            mac_setTrxState(PHY_TRX_OFF);        
            macInfo.sState.nTransacType  = MAC_TRANSAC_NO;
            macInfo.sState.nTransacState = MAC_TRANSAC_NO;
            schedul_removeTask(TASK_PER_MAC_TRANSACTION); /*Remove task in queue */
            break;
        default:
            break;
        }
    }
    else{} //TBD

} // End of functions

/******************************************************************************/
//@FunctionName:   										  	                  */
//@Description:	                                                              */
//	                                                                          */    
//@Param                                                                      */
//	                                                                          */   
/******************************************************************************/
void mlmeRxEnableRequest(BOOL DeferPermit, UINT32 RxOnTime, UINT32 RxOnDuration)
{
	/*********** Variable declaration ***********/
    RXENABLE_INFO*  pRxEndableInfo;
	/*********** Function body		 ***********/
    /*In the non-beacon network */
    if (mpib.macBeaconOrder == 15)
    {
        /* RX Enable request should be a transaction, add task to transaction queue */
        pRxEndableInfo = mem_getMem(sizeof(RXENABLE_INFO));
        pRxEndableInfo->nDuration = (RxOnDuration + (aUnitBackoffPeriod - 1)) / aUnitBackoffPeriod;
        mac_requestState(MAC_TRANSAC_RXENABLE,RX_ENABLE);
        schedul_addTask(mlme_handleRxEnableTask, TASK_PER_MAC_TRANSACTION,pRxEndableInfo);
    }
} // End of functions

//---------------------------------------------------------------------------------------------------------------
//---                                           MLME-SYNC.request                                                  
//---------------------------------------------------------------------------------------------------------------
// MLME-SYNC.request is generated by the next higher layer of    */
//              a device on a beacon-enabled PAN and issued to its MLME to    */
//              synchronize with the coordinator
//              This request will change the current status of TRx then it
//              must be sync with other task using Trx, ex. trans task. This
//              request must be queue in TASK_TX to be sync
//---------------------------------------------------------------------------------------------------------------
void        beacon_synsBeaconTask(void* Param,void* arg1);
MAC_STATUS  mlmeSyncRequest(UINT8   LogicalChannel, // The logical channel on which to attempt coordinator synchronization
                            BOOL    TrackBeacon)    // TRUE --> if the MLME is to synchronize with the next beacon and attempt to track all future beacons
{
    /*********** Variable declaration ***********/
    BYTE*           pTem;
    WORD            DataTask;
    /*********** Function body       ***********/
    pTem = &DataTask;
    pTem[0] = LogicalChannel;
    pTem[1] = TrackBeacon;
    schedul_addTask(beacon_synsBeaconTask,TASK_PER_MAC_PERIODICAL,(DWORD*)DataTask);/*Type cast from WORD to pointer*/
    return SUCCESS;
} // End of functions


#if     ZIGBEE_DEVICE_FFD == TRUE  
//---------------------------------------------------------------------------------------------------------------
//---                                           MLME-START.request                                                  
//---------------------------------------------------------------------------------------------------------------
// The MLME-START.request primitive makes a request for the device to start using a new superframe
// configuration.
//---------------------------------------------------------------------------------------------------------------
void beacon_startBeacon(void* par_pTimer, void* par_pParam);
void mlmeStartRequest(WORD PanId, UINT8 LogicalChannel, UINT8 BeaconOrder, 
                      UINT8 SuperframeOrder, BOOL PanCoordinator, BOOL BatteryLifeExtension, 
                      BOOL  CoordRealignment, BOOL SecurityEnable,
                      UINT32 StartTime)
{
	/*********** Variable declaration ***********/
    WORD        mdmctrl0;
    MAC_STATUS  returnStatus;
    OS_TMR*     pTimer;
	/*********** Function body		 ***********/
    returnStatus = SUCCESS;
    /* Check parameters */
    if (!((LogicalChannel >= 11) && (LogicalChannel <= 26)) 
        || (BeaconOrder > 15) 
        || ((SuperframeOrder > BeaconOrder) && (SuperframeOrder != 15)))
        returnStatus = INVALID_PARAMETER;
    /* Check the address */    
    if (mpib.macShortAddress >= VALID_SHORT_ADDR)
        returnStatus = NO_SHORT_ADDRESS;
    /* Check if need to set macSuperframeOrder to 15 */
    if (BeaconOrder == 15)
    {
        BeaconInfo.bTransmitBeacon  = FALSE;
        mpib.macSuperframeOrder     = 15;                
    }
    else
    {
        mpib.macBeaconOrder     = BeaconOrder;
        mpib.macSuperframeOrder = SuperframeOrder;
    }
    
    mlmeSetRequest(MAC_BATT_LIFE_EXT, &BatteryLifeExtension);
    mlmeSetRequest(MAC_PAN_ID, &PanId);                         /* Set the PAN ID */   
    plmeSET_request(PHY_PIB_CURRENT_CHANNEL,LogicalChannel);    /* Change the RF channel */

    mdmctrl0 = 0x0AE2;
    if (PanCoordinator) 
    {          
        macInfo.DeviceType = ZIGBEE_PAN_COOR;             
        mdmctrl0 |= 0x1000; // Set the MDMCTRL0.PAN_COORDINATOR               
    } 
    else 
        macInfo.DeviceType = ZIGBEE_DEVICE_FFD;

    DISABLE_GLOBAL_INT();
    FASTSPI_SETREG(CC2420_MDMCTRL0, mdmctrl0);
    ENABLE_GLOBAL_INT();
    
    /* Broadcast the coordinator realignment cmd */
    if (CoordRealignment) 
    {
        /* TBD */
    }

    /* If transmitting the beacon, the change of parameter will be applied later */
    /* If not, transmit the beacon with super-frame configuration now */
    beacon_initBeacon();    /*Init trans beacon*/
    if (BeaconOrder == 15)
    {
        /* If it is transmitting, stop it*/
        BeaconInfo.bTransmitBeacon = FALSE;
        beacon_endBeaconTx();
    }
    else /* Transmit the beacon */
    {
        BeaconInfo.bTransmitBeacon = TRUE;
        if (StartTime == 0)
        {            
            BeaconInfo.nBeaconOffset = 0;
            beacon_startBeacon(NULL,NULL);
        }
        else
        {
            pTimer = OSTmrCreate(0,StartTime,OS_TMR_OPT_ONE_SHOT,beacon_startBeacon,
                                 NULL,NULL,&mdmctrl0);
            OSTmrStart(pTimer,&mdmctrl0);            
        }
    }    

    mlmeStartConfirm(returnStatus);
} // End of functions

//---------------------------------------------------------------------------------------------------------------
//---                                           The MLME-ORPHAN.response                                                  
//---------------------------------------------------------------------------------------------------------------
//The MLME-ORPHAN.response primitive allows the next higher layer of a coordinator to respond to the
//MLME-ORPHAN.indication primitive.
//---------------------------------------------------------------------------------------------------------------
void mlmeOrphanResponse(QWORD* pOrphanAddress, WORD shortAddress, 
                        BOOL associatedMember, BOOL securityEnable) 
{
	/*********** Variable declaration ***********/
    P_MPDU_TX       pMpduTx;
    BYTE*			pPayload;
	MAC_STATUS		macStatus;
	/*********** Function body		 ***********/

    /*Ignore this response if the associatedMember field is FALSE*/
    if (associatedMember) {
        pMpduTx = mem_getFreeTxPkt();
        pPayload = pMpduTx->Mpdu.PayLoad;

        /*Format the payload of the realignment cmd*/
        *(pPayload++) = CMD_COORDINATOR_REALIGNMENT;
        // Generate the packet payload
        *(pPayload++) = (BYTE) mpib.macPANId;
        *(pPayload++) = (BYTE) ((mpib.macPANId & 0xFF00) >> 8);
        *(pPayload++) = (BYTE) mpib.macShortAddress;
        *(pPayload++) = (BYTE) ((mpib.macShortAddress & 0xFF00) >> 8);
        *(pPayload++) = PhyInfo.PhyPIB.phyCurrentChannel;
        *(pPayload++) = (BYTE) shortAddress;
        *(pPayload)   = (BYTE) ((shortAddress & 0xFF00) >> 8);        
        
        macStatus = mac_formatMpdu(pMpduTx,
                                   MAC_FRM_CMD,
                                   AM_EXTENDED_64,
                                   mpib.macPANId,
                                   (ADDRESS *) &aExtendedAddress,
                                   AM_SHORT_16,
                                   mpib.macPANId,
                                   (ADDRESS *) &mpib.macCoordShortAddress,
                                   0,
                                   pMpduTx->Mpdu.PayLoad,
                                   8);

        //set other information
        pMpduTx->PktInfo.txMode         = TX_MODE_NO_CSMACA;
        pMpduTx->PktInfo.nRetryLeft     = aMaxFrameRetries;                           
    }
} // End of functions
        

#endif  // ! ZIGBEE_DEVICE_FFD == TRUE  
